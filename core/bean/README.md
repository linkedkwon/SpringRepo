# 빈(Bean)
<a href="http://melonicedlatte.com/">
    <img src="https://img.shields.io/badge/Spring-red"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Core-orange"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
    <img src="https://img.shields.io/badge/Bean-yellow"
        style="height : auto; margin-left : 8px; margin-right : 8px;"/>
</a>

## 1. 빈이란?
일반적인 Java 프로그래밍에서는 개발자가 new 연산자, 인터페이스, 또는 팩토리 호출 방식 등의 방식으로 인스턴스를 생성하고 원하는 
스코프(Scope)와 생명주기를 **직접 설계하여 사용**한다. 반면에 Spring 프레임워크는 이같은 역할을 외부에서 대신 위임받아 수행한다. 
이는 **제어의 역전**으로 `IoC(Inversion of Control) 컨테이너`를 통해 **자동으로 인스턴스의 생명주기를 관리하고 의존성을 
주입하는 기능**을 제공하는데, 이때 컨테이너에서 관리되는 인스턴스를 빈이라 부른다. 빈은 기본적인 필드와 getter & setter 등의 
메소드만을 둔 `POJO(Plain Old Java Object)` 상태이며, 설정 정보를 등록해 생명주기와 의존 관계 등을 설정할 수 있다.

<img width="569" alt="bean" src="https://user-images.githubusercontent.com/78818063/174931957-239f092b-6f63-4789-824f-5b0e9316112e.png">

<br>

## 2. 빈의 이점
앞서 Spring에서 인스턴스를 다루는 방법과 함께 빈의 정의에 대해 알아 보았는데, 그렇다면 빈을 사용함으로서 얻을 수 있는 이점들은 
무엇인지 아래 항목들을 살펴보자. 

  * ### 의존성 관리 ###
    객체의 POJO 상태를 유지하기 위해 특정 객체가 다른 객체를 필요로 하는 경우에는 이를 주입받아 사용해야 한다. 
    개발자는 매번 객체를 생성하고 주입하는 코드를 작성해야 하는데, **IoC 컨테이너는 이러한 의존 관계에 있는 객체를 
    미리 빈으로 생성해두고 핃요할 때 자동으로 주입**시켜 준다.

  * ### 싱글톤(Singleton) 유지 ###
    `싱글톤`이란 객체의 **인스턴스가 애플리케이션이 시작될 때 오직 한 번만 생성되도록 하는 디자인 패턴**을 의미한다. 싱글톤은 
    보통 웹 서비스와 같은 대규모 트래픽과 멀티 스레딩 환경에서 동시성을 제어하기 위해 사용된다. 수많은 요청에 따라 매번 인스턴스를 
    생성하는 것이 아닌 요청 흐름에 따라 수행할 작업을 여러 개의 레이어 계층으로 분리하고, 각 작업을 수행할 인스턴스를 무상태(Stateless)로 
    만들어 공유할 수 있도록 설계한다. 이처럼 작업에 필요한 **인스턴스는 내부 상태 변화가 없다.** 즉 매번 인스턴스를 생성하지 않고 
    **IoC 컨테이너에서 싱글톤 스코프의 빈으로 등록하면, 메모리 사용 효율을 높이고 런타임 성능을 최적화** 할 수 있다.

    <img width="597" alt="singleton" src="https://user-images.githubusercontent.com/78818063/174931971-5610538a-d581-451f-8ae3-5ae325b91776.png">

  * ### 빈 생명주기 인터페이스 지원 ###
    Spring은 빈의 **생명주기에 따라 부가적인 작업을 수행할 수 있는 인터페이스를 제공**한다. `postconstruct`와 같이 생명주기를 
    활용하는 어노테이션들을 사용할 수 있으며, 보통 객체의 생성, 소멸과 같은 생명주기에 **특정 동작을 추가하거나 필드를 검사하는 등 
    유용한 기능을 추가**할 수 있다.
    
<br>

## 3. 빈 설정과 등록 방법
마지막으로 빈을 등록하는 방법에 대해 다룬다. 기존 xml 기반 방식은 설정 정보의 가독성이 떨어지고 규모가 커짐에 따라 관리하기가 힘들어 
현재는 **어노테이션(Annotation)과 클래스 파일을 통해 빈을 등록**할 것을 권장한다. 아래에서 빈을 등록하는 기본적인 방법들에 대해 알아보자.

  * ### 1-1. xml 기반 빈 설정 ###
    가장 기본적인 빈 설정 방법으로 `xml` 파일에 **빈으로 사용할 클래스 정보를 명시**한다. 해당 정보는 컨테이너에 전달할 빈의 모든 정보를 담은 
    메타데이터 파일인 `application.xml`에 명시하며, 여러 개의 파일로 나눠 구조화 할 수도 있다. 이러한 방식은 **수정이나 확장에 있어 유연한 설정**이 
    가능하단 큰 장점을 가지는 반면 **가독성이 낮고 관리가 힘들어** 생산성에서는 매우 비효율적이다. 기본적인 사용법은 파일 내부에 `태그`와 `프로퍼티`를 
    통해 사용할 클래스의 정보를 기입하면 된다. 아래는 기본 등록 방법과 주요 태그 및 프로퍼티를 참고하자.  
    
    <img width="771" alt="xml" src="https://user-images.githubusercontent.com/78818063/174932332-c9279f21-7491-4f02-b98d-6442ae0a4b4f.png">
   
    <br>
    
    * `<bean>` : 등록할 빈의 정보를 명시하는 태그
    * `id` : 빈의 이름을 지정하는 속성으로 다른 빈에서 의존성을 주입할 때 사용함.
    * `class` : 빈으로 등록할 클래스의 위치를 지정하는 속성
    * `<property>` : 해당 빈의 의존성 주입 정보를 명시하는 태그
    * `name` : 의존성을 주입 받을 변수명을 명시
    * `ref` : 의존성을 주입 받을 빈의 이름을 명시
      
    <br>
    
    <img width="770" alt="beanRef" src="https://user-images.githubusercontent.com/78818063/174932392-13cb39c7-2eac-4bf0-a1d7-006b3088e315.png">
    
  * ### 1-2. Java 기반 빈 설정 - 선언적 방식 @Component ###
    Java 설정을 통한 빈 설정 방식은 기존 xml 파일을 통한 설정의 단점을 극복하기 위해 등장하였다. 
    먼저 가장 기본적인 `@Component` 어노테이션이다. 이는 선언적(Declarative) 방식으로 **빈으로 
    등록할 클래스 선언부 상단에 위 어노테이션을 명시**하면, 스캔 시 이를 식별하여 빈을 생성해 준다. 
    보통 개발자가 **직접 작성한 클래스나 수정과 확장이 불필요한 기본 뼈대 클래스에 사용**되며, 
    레이어 계층에서 사용하는 `@Controller`, `@Service`, `@Repository` 들 또한 이를 구체화한 
    형태로 내부에 해당 어노테이션을 포함하고 있다. 또한 여러 어노테이션들과 함께 사용는데, 자세한 내용은 
    annotation 항목에서 다루도록 한다. 

    <img width="771" alt="component" src="https://user-images.githubusercontent.com/78818063/174933075-368728eb-2d1e-4637-8a8c-8934e0237448.png">
    
  * ### 1-3. Java 기반 빈 설정 - 설정 파일 @Configuration과 @Bean ###
    @Component이 선언적 방식이었다면 다음은 특정 비즈니스에 **관련된 여러 빈을 설정할 파일을 만들어 관리하는 방법**이다. 
    먼저 빈을 모아둘 클래스 파일을 만들어 **클래스 선언부 상단에 `@Configuration`을 명시해 준다**. 이는 해당 클래스가 
    빈으로 구성된 환경 설정 파일인 것을 나타내며, 내부에 **@Component를 내장하고 있으므로 스캔 시 등록 대상**이 된다. 
    다음으로 내부에 **빈으로 사용할 클래스를 리턴하는 메소드를 만들고 메소드 선언부 상단에 `@Bean` 어노테이션을 명시**한다. 
    이같은 방식은 보통 **개발자가 직접 제어가 불가능한 외부 라이브러리를 사용하거나 수정과 확장 시 유연한 설정**을 위해 사용되어 
    진다. 아래는 설정 파일을 통한 빈 설정 방식의 기본 사용법이다. 

    <img width="771" alt="configurationAndBean" src="https://user-images.githubusercontent.com/78818063/174932966-babcdef2-6c76-465b-9c21-53ef8496ae19.png">


<br>

앞서 빈으로 사용할 클래스를 설정하는 세 가지 방식에 대해 알아보았다. 이제 **빈의 메타데이터를 컨테이너에게 전달**해 등록해야 한다. 
Spring에서 빈을 등록하는 방법은 모두 두 가지로 아래와 같다. 

  * ### 2-1. 직접 등록 ###
    가장 기본적인 방법은 빈 팩토리를 상속받는 컨테이너 클래스의 인스턴스를 생성해 **직접 빈 설정 정보를 등록**하는 것이다. 이는 
    **직접적으로 파일을 명시해 등록 시간이 빠르단** 장점을 지니지만 여러 개의 메타데이터를 모두 설정해야 하므로 코드가 복잡해지고 
    번거롭다는 단점이 있다. 기본적인 사용법은 아래의 코드에서 보여주고 있는데, xml과 어노테이션 중 사용한 설정 방식에 따라 **적합한 
    클래스를 상속받아 인스턴스화한 뒤** `getBean()` **메소드를 호출**하면 된다. 

    <img width="771" alt="context" src="https://user-images.githubusercontent.com/78818063/174933184-7cc7713c-fe5a-44a2-ac58-ed9d8b96383c.png">

  * ### 2-2. 컴포넌트 스캔 방식 ###
    `컴포넌트 스캔`은 직접 등록 방식의 단점을 극복하기 위해 나온 기능으로, **빈으로 등록될 준비가 된 클래스들을 스캔하여 빈으로 등록하는 
    과정을 의미**한다. **@Component 어노테이션이 붙어있는 클래스**들은 전부 스캔 대상이 되며, 이를 사용하기 위해서는 **설정 정보 클래스에 
    `@ComponentScan `어노테이션을 함께 붙여줘야 한다**. 이떄 스캔의 범위는 기본적으로 설정 정보 클래스의 패키지를 포함한 모든 하위 패키지가 
    된다. 따라서 아래와 같이 **탐색이 필요한 패키지 위치를 적절히 명시**해주는 것이 바람직하다. 참고로 Spring Boot의 `@SpringBootApplication` 
    어노테이션의 내부에도 컴포넌트 스캔의 어노테이션이 포함되어 있어 별도의 스캔 과정 없이도 빈이 등록된다.

    <img width="771" alt="componentScanXML" src="https://user-images.githubusercontent.com/78818063/174933369-a0334a3f-daf3-4371-a46e-2bac35416ed3.png">

    <img width="771" alt="componentScanJava" src="https://user-images.githubusercontent.com/78818063/174933364-760e0502-1600-47c2-95f3-120ecd2f0fe7.png">

<br>
